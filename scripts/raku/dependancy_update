#!/usr/bin/env raku

use v6.d;
use TOML;


# sub MAIN($filename) {
#
#   my $file-content = $filename.IO.slurp;
#
#   my $deps = from-toml($file-content)<dependencies>;
#
#   # Build lookup table  
#   my %new-versions;
#   for $deps.kv -> $lib, $version {
#     my $ver = $version ~~ Hash ?? $version<version> !! $version;
#
#     my $new-ver = lookup-latest-version($lib);
#
#     %new-versions{$lib} = $new-ver;
#   }
#
#
#   say %new-versions
#   # for %new-versions.kv -> $lib, $new-ver {
#   #   $file-content .= subst($lib, $new-ver);
#   # }
#   #
#   # # Write file
#   # $filename.IO.spurt($file-content);
#
# }
#
# sub lookup-latest-version($lib) {
#   my $output = qqx/cargo search $lib/;
#   return $output.lines[0].split(' ')[2].trans('"' => '').subst(':', '');
# }

sub MAIN($filename) {
    my $file-content = $filename.IO.slurp;
    my $deps = from-toml($file-content)<dependencies>;

    my %new-versions;
    for $deps.kv -> $lib, $version {
        my $ver = $version ~~ Hash ?? $version<version> !! $version;
        # say "$lib -> $ver";

        my $output = qqx/cargo search $lib/;
        my $package_version = $output.lines[0].split(' ')[2].trans('"'=>'').subst(':', ''); # Clean up version
	# say "Library name: $lib = old version: $ver => new version: $package_version";

	%new-versions{$lib} = $package_version;
	# $deps .= subst($ver, $package_version); 
	# say "New dep:\n $deps"
    }
    #   # for %new-versions.kv -> $lib, $new-ver {
#   #   $file-content .= subst($lib, $new-ver); # '.=' allows to use the original $file-content variable to rewrite its value.
#   # }$file-content = $

    for %new-versions.kv -> $lib, $package_version {
	$file-content .= subs
    }
    say %new-versions;

    $filename.IO.spurt($file-content);
}


# The idea is to create a list or even list of versions, then sort them and use substituion outside of the loop.

# $filename.IO.slurp reads the entire content of the file whose name is passed
# as an argument to the script.

# The .kv method is used with hashes (and other associative containers) to
# retrieve the keys and values as a list of pairs, where each pair is returned
# as two separate items: first the key, then the value.

# Because my hash is nested, we could say that the hash has a hash inside.
# And that's what i check here 'if $version ~~ Hash {' if key pair value is a
# nested hash, then i go search inside that hash looking for a 'version' key.

# The reason for the 'ver' to be initially equal to 'version' is because if
# there is no nested hash, then 'ver' is equal to version. Otherwire, it gets a
# new, correct value.

# ?? and !!: These operators are part of Raku's ternary conditional operator,
# which is used for inline conditional expressions. The syntax is condition ??
# true-expression !! false-expression. If the condition is true, the expression
# immediately following ?? is evaluated and returned; if the condition is false,
# the expression following !! is evaluated and returned.

# qqx is used to execute a command in the system's shell and capture its output.
# The slashes are just delimiters.
# - q: Single quotes, no interpolation or escape processing, except for \\ and \'.
# - qq: Double quotes, supports interpolation and escape sequences like \n, \t,
# etc.
# - qx: Similar to backticks in other languages, executes a shell command but does
# not allow interpolation.
# - qqx: Combines the features of qq and qx, allowing both interpolation and the
# execution of the resulting string as a shell command.
