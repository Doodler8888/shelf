#!/usr/bin/env raku

use v6.e.PREVIEW;
use Test;
use Test::Mock;

sub get_abs_path($path) {
  return $path if $path ~~ rx/^ \/ /; 
  return "{$*CWD}/{$path}";
}

#| Create symlink with or without destination argument
multi sub MAIN($target, $link-location?) {

  my $abs-target = get_abs_path($target);
  my $final-link-location = $link-location.IO.d ?? "{$link-location}/{$abs-target.IO.basename}" !! $link-location // "/usr/local/bin";

  mkdir $final-link-location.IO.dirname;
  symlink $abs-target, $final-link-location;

  say "Symbolic link created for $abs-target at $final-link-location";
}

class LinkCreator {
    # Encapsulate the symlink creation logic within a method
    method create-symlink(Str $target, Str $link-location?) {
        my $abs-target = self.get-abs-path($target);
        my $final-link-location = $link-location.IO.d ?? "{$link-location}/{$abs-target.IO.basename}" !! $link-location // "/usr/local/bin";

        mkdir $final-link-location.IO.dirname;
        symlink $abs-target, $final-link-location;

        say "Symbolic link created for $abs-target at $final-link-location";
    }

    method get-abs-path($path) {
        return $path if $path ~~ rx/^ \/ /;
        return "{$*CWD}/{$path}";
    }
}

multi sub MAIN('test') {
    plan 1;

    # Create a mock of the LinkCreator class
    my $mock = mocked(LinkCreator);

    # Perform the action using the mocked object
    $mock.create-symlink("test.toml", "~/");

    # Assert the expected method calls
    # Adjust the expected path according to the actual logic of create-symlink
    check-mock($mock,
        *.called('create-symlink', with => \( "test.toml", "~/" )), # Use the same argument as passed to the method
    );
}

# my $final-link-location = $link-location // "/usr/local/bin";
#
# if $final-link-location.IO ~~ :d {
#     $final-link-location = "{$final-link-location}/{$abs-target.IO.basename}";
# }

# Asterisk (*) and Special Variables
#
# The asterisk (*)  preceding CWD has a special meaning in Raku. It signals that
# CWD is a part of a dynamic variable family.  Here's a breakdown:
#
# Dynamic Variables: These variables aren't tied to lexical scopes like variables
# you declare with my. They often hold runtime information about the program or
# environment.
# The * Family: Variables marked with * usually provide global information
# relevant to how your program executes. Some other members of this family
# include:
# $*OUT: The standard output handle
# $*ERR: The standard error handle
# $*PID: The current process ID
# Why Is $*CWD Necessary?
#
# The  reason $*CWD is used, rather than relying on a  plain CWD form, stems from
# the nature of relative paths and how your process might be run.  Dynamic
# variables ensure access to  the correct, most-up-to-date   working directory,
# even if changes occur during script execution.
