#!/usr/bin/env raku

use v6.e.PREVIEW;


sub get_abs_path($my_path is copy) {
    $my_path ~~ s/^ '~' | '~/'/%*ENV<HOME>/;
    return $my_path if $my_path ~~ /^ \/ /;   
    return "{$*CWD}/{$my_path}";
}

#| Create symlinks for any number of targets with /usr/local/bin as a default destination
sub MAIN(*@files, Str :d(:$destination)="/usr/local/bin") {
    for @files -> $file {
        my $abs-file = get_abs_path($file);
        my $final-link-location = get_abs_path($destination);
        $final-link-location ~= "/{$abs-file.IO.basename}" if $final-link-location.IO.d;

        mkdir $final-link-location.IO.dirname; 
        symlink $abs-file, $final-link-location;

        say "Symbolic link created for $abs-file at $final-link-location";
    }
}

# #| Create symlink on a single target
# multi sub MAIN($target, $link-location="/usr/local/bin") {
#
#   my $abs-target = get_abs_path($target);
#   my $final-link-location = $link-location; # The final variable is created because i can't modify parameters, they are immutable.
#   $final-link-location ~= "/{$abs-target.IO.basename}" if $final-link-location.IO.d;
#
#   mkdir $final-link-location.IO.dirname;
#   symlink $abs-target, $final-link-location;
#
#   say "Symbolic link created for $abs-target at $final-link-location";
# }
#
# #| Create symlinks on multiple targets
# multi sub MAIN(*@targets, Str :d(:$destination)!) {
#
#   for @targets -> $target {
#     my $abs-target = get_abs_path($target);
#     my $final-link-location = $destination;
#     $final-link-location ~= "/{$abs-target.IO.basename}" if $final-link-location.IO.d;
#
#     mkdir $final-link-location.IO.dirname; 
#     symlink $abs-target, $final-link-location;
#
#     say "Symbolic link created for $abs-target at $final-link-location";
#   }
# }

# *@targets - without the *: If you remove the *, making the signature something
# like sub MAIN(@targets, Str :$link-location), Raku no longer treats @targets
# as a slurpy array. Instead, it expects exactly one positional argument that
# must be an array. 


# class LinkCreator {
#     # Encapsulate the symlink creation logic within a method
#     method create-symlink(Str $target, Str $link-location?) {
#         my $abs-target = self.get-abs-path($target);
# 	my $final-link-location = $link-location // "/usr/local/bin";
# 	# $final-link-location = "{$final-link-location}/{$abs-target.IO.basename}" if $final-link-location.IO.d;
#
#         mkdir $final-link-location.IO.dirname;
#         symlink $abs-target, $final-link-location;
#
#         say "Symbolic link created for $abs-target at $final-link-location";
#     }
#
#     method get-abs-path($path) {
#         return $path if $path ~~ rx/^ \/ /;
#         return "{$*CWD}/{$path}";
#     }
# }
#
# multi sub MAIN('test') {
#     use Test;
#     use Test::Mock;
#
#     my $mock = mocked(LinkCreator);
#
#     plan 1;
#
#     $mock.create-symlink("test.toml", "~/");
#     check-mock($mock,
#         *.called('create-symlink', with => \( "test.toml", "~/" )), # Use the same argument as passed to the method
#     );
#
#     plan 2;
#
#     $mock.create-symlink("test.toml");
#     check-mock($mock,
#         *.called('create-symlink', with => \( "test.toml" )), # Use the same argument as passed to the method
#     );
# }
